#!/bin/bash 
### This file ~/wsprdaemon/bash-aliases  includes functions and aliases which are helpful in running and debugging WD systems

shopt -s -o nounset

### Each element containsa the function name, a comma-seperated list of its aliases, and a description of it
### ie.e:  "FUNCTION_NAME:  ALIAS1,ALIAS2.,... DESCRIOTION"
declare WD_BASH_HELP_LIST=()
declare WD_BASH_HELP_HEADER_LINE_LIST=( "FUNCTION"  "ALIAS(es)"  "DESCRIPTION" )

function wd-print-help-strings() {
    local function_name_field_width=${#WD_BASH_HELP_HEADER_LINE_LIST[0]}
    local alias_name_field_width=${#WD_BASH_HELP_HEADER_LINE_LIST[1]}
    local help_string_index

    ### Calculate the width of fields which will be printed
    for (( help_string_index=0; help_string_index < ${#WD_BASH_HELP_LIST[@]}; ++ help_string_index )) do
        local help_string="${WD_BASH_HELP_LIST[${help_string_index}]}"
        local help_string_list=( ${help_string} )

        local function_name="${help_string_list[0]}"
        if [[ ${#function_name} -gt ${function_name_field_width} ]]; then
            function_name_field_width=${#function_name}
        fi
        local alias_names="${help_string_list[1]}"
        if [[ ${#alias_names} -gt ${alias_name_field_width} ]]; then
            alias_name_field_width=${#alias_names}
        fi
    done

    printf "%${function_name_field_width}s  %${alias_name_field_width}s  %s\n" \
               "${WD_BASH_HELP_HEADER_LINE_LIST[0]}" "${WD_BASH_HELP_HEADER_LINE_LIST[1]}" "${WD_BASH_HELP_HEADER_LINE_LIST[2]}"

    for (( help_string_index=0; help_string_index < ${#WD_BASH_HELP_LIST[@]}; ++ help_string_index )) do
        local help_string="${WD_BASH_HELP_LIST[${help_string_index}]}"
        local help_string_list=( ${help_string} )

        local function_name="${help_string_list[0]}"
        local alias_names="${help_string_list[1]}"
        local description_string="${help_string_list[@]:2}"

        printf "%${function_name_field_width}s  %${alias_name_field_width}s  %s\n" "${function_name}" "${alias_names}" "${description_string}"
    done
}

WD_BASH_HELP_LIST=( "wd_logger  wdl  Emulate WD's wd_logger() function when these functions are run from the linux cmd line" )

### When this file is sourced by wsprdaemon.sh this function will be redefined in wd-utils.sh to the full wd_logger() used by WD
function wd_logger(){
    local verbosity_printing_level=${1:-1}
    local printout_string="${2:-Missing printout string}"

    if [[ ${verbosity_printing_level} -ge ${verbosity:-1} ]]; then
        echo -e "${printout_string}"
    fi
}

WD_BASH_HELP_LIST+=( "wd-machine_name - Executes 'uname -m'" )
function wd-machine-name() {
    echo $(uname -m)
}

function wd-flush-empty-dirs() {
    for dir in * ;  do 
        if [[ -d $dir ]]; then
            file_count=$(find $dir -type f | wc -l)
            if [[ $file_count -eq 0 ]]; then 
                echo "Deleting empty directory $dir"
                rm -r $dir
            fi
        fi
    done
}

function wd-find-functions() {
   local bash_file=$1

   local functions_list=( $( awk '/^function/{print $2}' ${bash_file} | sed 's/(.*//' ) )

   echo "Found ${#functions_list[@]} functions: '${functions_list[*]}'"

   for function in ${functions_list[@]} ; do
       grep -w ${function}  ${bash_file}
       read
   done
}

export LC_TIME="C"          ### Forces user session 'date' to display 24 hour time

if [[ -d /dev/shm/wsprdaemon ]]; then
    WD_TMP_ROOT=/dev/shm/wsprdaemon
else
    WD_TMP_ROOT=/tmp/wsprdaemon
fi

### To speed debugging of the WD upload daemons, kill just the watchdog and upload daemons.  You can then 'wda' and watch the upload log as the WD uploader starts to work immediately
function wd-kill-uploader()
{
    kill $( cat ~/wsprdaemon/watchdog_daemon.pid  ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.pid )
}
alias wd-k=wd-kill-uploader
alias wdk=wd-kill-uploader

### Watch the upload log file
function wd-watch-wsprnet-upload-log()
{
    echo "To view the full log file execute the command: 'less ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.log'"
    tail -F ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.log
}
alias wd-un=wd-watch-wsprnet-upload-log
alias wdln=wd-watch-wsprnet-upload-log

### Gets status for the Kiwis listed in WD.conf
function wd-find-kiwis()
{
    local local_lan_list=( $(ip addr | grep -w inet | grep -v 'inet 127' | awk '{print $2}' | sed 's;\.[0-9]*/;.0/;g') )

    [[ ${verbosity} -gt 0 ]] && echo "Searching the ${#local_lan_list[@]} LANs for Kiwis:  ${local_lan_list[@]}"
    for lan in ${local_lan_list[@]} ; do
        echo "Searching LAN ${lan} for Kiwis"
        local kiwi_ip_list=( $( nmap --open -p 8073 ${lan} | awk '/Nmap scan report for/{print $5}' ) )
        if [[ ${#kiwi_ip_list[@]} -eq 0 ]]; then
            echo "Found no Kiwis"
        else
            echo "Found ${#kiwi_ip_list[@]} Kiwis: ${kiwi_ip_list[*]/%/  }"
        fi
    done
}

function wd-kiwi-status()
{
    local wsprconf_file=~/wsprdaemon/wsprdaemon.conf;
    if [[ ! -f ${wsprconf_file} ]]; then
        echo "ERROR: can't find config file ${wsprconf_file}";
        return;
    fi;
    source ${wsprconf_file};
    local kiwi_list=();
    for rx_line in "${RECEIVER_LIST[@]}";
    do
        local rx_fields=(${rx_line});
        local rx_name=${rx_fields[0]};
        local rx_ip_port=${rx_fields[1]};
        if [[ ${rx_name} =~ AUDIO* ]] || [[ ${rx_name} =~ MERG* ]] || [[ ${rx_name} =~ RTL* ]]; then
            [[ ${verbosity} -ge 1 ]] && echo "skipping rx ${rx_name}";
        else
            local rx_ip=${rx_ip_port/:*/};
            if ! ping -c 1 -W 1 ${rx_ip} > /dev/null; then
                echo "WARNING: the Kiwi '${rx_name}' defined in ${wsprconf_file} doesn't respond to pings";
            else
                kiwi_list+=(${rx_name},${rx_ip_port});
                [[ ${verbosity} -ge 1 ]] && echo "Added ${rx_name} => ${rx_ip}";
            fi;
        fi;
    done;
    [[ ${verbosity} -ge 1 ]] && echo "kiwi_list[@] => ${kiwi_list[@]}";
    [[ ${verbosity} -ge 1 ]] && echo;
    local users;
    local users_max;
    local gps_good;
    local users_total=0;
    local wsprdaemon_total=0;
    local channels_total=0;
    for kiwi_info in "${kiwi_list[@]}";
    do
        local kiwi_name=${kiwi_info%,*};
        local kiwi_ip=${kiwi_info#*,};
        local kiwi_status="$(curl -s http://${kiwi_ip}/status)";
        users=$(sed -n '/users=\(.*\)/s//\1/p' <<< ${kiwi_status});
        users_max=$(sed -n '/users_max=\(.*\)/s//\1/p' <<< ${kiwi_status});
        channels_total=$((channels_total + users_max));
        gps_good=$(sed -n '/gps_good=\(.*\)/s//\1/p' <<< ${kiwi_status});
        [[ ${verbosity} -ge 1 ]] && printf "%15s: %d channels, %d users, %2d GPS satellites tracked\n" "${kiwi_name}" "${users_max}" "${users}" "${gps_good}";
        curl -s http://${kiwi_ip}/users | sed -n 's/"i":\([0-9]*\)/\n\1/g ; s/},{//g ; p' | sed '/\[{/d; s/}]//; s/,/     /g' > /tmp/curl.log;
        while read user_line; do
            [[ ${verbosity} -ge 1 ]] && echo "Checking '${user_line:1}' on user line ${user_line}"
            if grep --color=auto -q wsprdaemon <<< "${user_line}"; then
                [[ ${verbosity} -ge 1 ]] && echo "skipping WD user";
                wsprdaemon_total=$((wsprdaemon_total + 1));
            else
                [[ ${verbosity} -ge 1 ]] && echo "Checking '${user_line:1}' on user line ${user_line}"
                if [[ -n "${user_line:1}" ]]; then
                    eval declare $(echo "${user_line:1}" | sed '/"\([^"]*\)":/s//\1=/g');
                    [[ $? -ne 0 ]] && continue
                    local listener_channel="${user_line:0:1}";
                    local listener_name="$(echo "$n" | sed 's/%20/ /g')";
                    local listener_location="$(echo "$g" | sed 's/%20//g')";
                    local listener_freq="$f";
                    local listener_mode="$m";
                    local listener_ip="$a";
                    local listener_time="$t";
                    printf "%12s:%s %20s %8s %3s %s %20s %s\n" "${kiwi_name}" "${listener_channel}" "'${listener_name}'" "${listener_freq}" "${listener_mode}" "${listener_time}" "${listener_ip}" "${listener_location}";
                    users_total=$((users_total + 1));
                fi;
            fi;
        done < /tmp/curl.log;
    done;
    printf "Found %d Kiwis configured for %d total rx channels, %d total listeners, %d wsprdaemon channels\n" "${#kiwi_list[@]}" $channels_total $users_total $wsprdaemon_total
}

### 'git commit'
function wd-gc()
{
    if [[ -z "$1" ]]; then
        echo "usage:  wd-gc \"commit message\""
        return
    fi
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob"
    git commit -m "$1" -a
}

### 'git push'
alias wd-gp='git push'

#### Get the most recent commit
alias wd-gl='git log | head -n 12'

### Setup a WD server 'git cloned' with https, so it can checkin to github with ssh
function wd-gc-ssh() {
    git remote set-url origin git@github.com:rrobinett/wsprdaemon.git 
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob Robinett"
}

### Reload this file
alias wd-rc='source ~/wsprdaemon/bash-aliases'       ### Just reload this file
alias wdrc='wd-rc'

### Add sourcing this file to ~/.bash_aliases so that these bash aliases and functions are defined in every bash session
function wd-rci() 
{
    if [[ ! -f ~/.bash_aliases ]] || ! grep '/bash-aliases' ~/.bash_aliases > /dev/null ; then
        echo "
if [[ -f ~/wsprdaemon/bash-aliases ]]; then
    source ~/wsprdaemon/bash-aliases
fi
" >> ~/.bash_aliases
         echo "A reference to '~/wsprdaemon/bash-aliases' has been added to ' ~/.bash_aliases'"
    else
         [[ ${verbosity-0} -gt 1 ]] && echo "bash-aliases has already been installed in ~/.bash_aliases"
    fi
}
wd-rci
alias wdrci='wd-rci'

### Reload the local bash aliases and funtions defined in its ~/.bash_aliases, which will include this file after 'rci' has been executed
alias wd-rcc='source ~/.bash_aliases'
alias wd-rcc='wd-rcc'

### Common usages of Linux commands
alias l='ls -CF'
alias ll='ls -l'
alias lrt='ls -lrt'
alias la='ls -A'

alias pd=pushd
alias d=dirs

alias ag='alias | grep'

alias h=history
alias hg='history | grep'
alias j=jobs

alias cdw='cd ~/wsprdaemon/'
alias cdww='cd ~/wsprdaemon/wav-archive.d/'
alias cdk='cd ~/wsprdaemon/ka9q-radio'
alias cdt='cd /dev/shm/wsprdaemon'
alias cdu='cd /dev/shm/wsprdaemon/uploads.d/'

### Start 'vi' using WD's .vimrc
function vi() 
{
    local vim_rc_file=~/.vimrc
    local wd_vim_rc_file=~/wsprdaemon/.vimrc

    if [[ ! -f ${vim_rc_file} ]] || ! grep wsprdaemon ${vim_rc_file}  > /dev/null ; then
        echo "Adding 'source ${wd_vim_rc_file}' to ${vim_rc_file}"
        echo "source ${wd_vim_rc_file}" >> ${vim_rc_file}
    fi
    vim $*
}

alias vib='vi ~/wsprdaemon/bash-aliases'
alias vibb='vi ~/.bash_aliases'
alias viw='vi ~/wsprdaemon/wsprdaemon.sh'
alias vic='vi ~/wsprdaemon/wsprdaemon.conf'
alias vir='vi ~/wsprdaemon/radiod@rx888-wsprdaemon.conf'
alias virr='vi /etc/radio/radiod@rx888-wsprdaemon.conf'

alias tf='tail -F -n 40'
alias tfd='tf decoding_daemon.log'
alias tfr='tf wav_recording_daemon.log'
alias tfw='tf ~/wsprdaemon/watchdog_daemon.log'

alias g='git'
alias gc='git commit'
alias gd='git diff'
alias gs='git status'

### Get pub file for a copy/past to remote server's .ssh/authorized_keys file
alias catss='cat ~/.ssh/*pub'

### Helps cleanup WD source files
function find_unused_vars() {
    local sh_file=$1

    local var
    local vars=$(cat ${sh_file} | sed -n '/^declare /s///p' | sed 's/=.*//')
    for var in ${vars}; do
        local lines=$(grep -v '^declare' ${sh_file} | grep ${var})
        if [[ -z "${lines}" ]]; then
            echo "Found no usage of variable ${var}"
        fi
    done
}

### Prepends the date to each response from 'ping'
function pinge() 
{
   if [[ -z "$1" ]]; then
       echo "usage:  pinge DEST"
       return 1
   fi
   local dest=$1
   local pong

   ping ${dest} | while read pong; do echo "$(date): ${pong}"; done
}


function setup-ubuntu() {
    local remote_ip=$1

    if [[ -z "${remote_ip}" ]]; then
        echo "usage: ${FUNCNAME[0]} USER@IPADDRESS"
        return 0
    fi
    local url_list=( ${remote_ip/@/ } )
    if [[ ${#url_list[@]} -ne 2 ]]; then
        echo "ERROR: URL '${remote_ip}' doesn't contain a 'USER@IP'"
    fi
    scp -p ~/.ssh/authorized_keys ${remote_ip}:.ssh/
    scp -p ~/.vimrc ~/.bash_aliases ${remote_ip}:
    ### In an interactive login session:  run visudo to setup NOPASSWD:, install vim, disable VNC encryption so RealVNC clients can login
    ssh ${remote_ip} "echo 'sudo visudo
    sudo apt update 
    sudo apt install vim -y
    sudo apt install git -y
    sudo apt install sox -y
    gsettings set org.gnome.Vino require-encryption false
    ' > setup-ubuntu.sh; chmod +x setup-ubuntu.sh"
    echo
    echo "Run './setup-ubuntu.sh' to finish this installation"
    echo
    ssh ${remote_ip} 
}

# Get status of all active kiwis
function kiwi-stats(){
    local wsprconf_file=~/wsprdaemon/wsprdaemon.conf

    if [[ ! -f ${wsprconf_file} ]] ; then
        echo "ERROR: can't find config file ${wsprconf_file}"
        return
    fi
    source ${wsprconf_file}

    ## Construct a list of configured and present Kiwis
    local kiwi_list=()
    for rx_line in "${RECEIVER_LIST[@]}"; do
        local rx_fields=(${rx_line})
        local rx_name=${rx_fields[0]}
        local rx_ip_port=${rx_fields[1]}
        if [[ ${rx_name} =~ AUDIO* ]] || [[ ${rx_name} =~ MERG* ]] || [[ ${rx_name} =~ RTL* ]] ; then
            [[ ${verbosity} -ge 1 ]] && echo "skipping rx ${rx_name}"
        else
            local rx_ip=${rx_ip_port/:*/}
            if ! ping -c 1 -W 1 ${rx_ip} > /dev/null ; then
                echo "WARNING: the Kiwi '${rx_name}' defined in ${wsprconf_file} doesn't respond to pings"
            else
                kiwi_list+=(${rx_name},${rx_ip_port})
                [[ ${verbosity} -ge 1 ]] && echo "Added ${rx_name} => ${rx_ip}"
            fi
        fi
    done
    [[ ${verbosity} -ge 1 ]] && echo "kiwi_list[@] => ${kiwi_list[@]}"
    [[ ${verbosity} -ge 1 ]] && echo

    local users
    local users_max
    local gps_good
    local users_total=0
    local wsprdaemon_total=0
    local channels_total=0
    for kiwi_info in "${kiwi_list[@]}" ; do
        local kiwi_name=${kiwi_info%,*}
        local kiwi_ip=${kiwi_info#*,}
        local kiwi_status="$(curl -s http://${kiwi_ip}/status)"
        users=$(sed -n '/users=\(.*\)/s//\1/p' <<< ${kiwi_status})
        users_max=$(sed -n '/users_max=\(.*\)/s//\1/p' <<< ${kiwi_status})
        channels_total=$((channels_total + users_max))
        gps_good=$(sed -n '/gps_good=\(.*\)/s//\1/p' <<< ${kiwi_status})
        [[ ${verbosity} -ge 1 ]] && printf "%15s: %d channels, %d users, %2d GPS satellites tracked\n" "${kiwi_name}" "${users_max}" "${users}" "${gps_good}"

        ### I was unable to parse the curl output when it was assigned to a bash variable. After some frustration I am using the hack of
        ### piping curl's output to a /tmp file and reading and parsing it from there

        curl -s http://${kiwi_ip}/users | sed -n 's/"i":\([0-9]*\)/\n\1/g ; s/},{//g ; p' | sed '/\[{/d; s/}]//; s/,/     /g' > /tmp/curl.log
        while read user_line; do
            if grep -q wsprdaemon <<< "${user_line}" ; then
                [[ ${verbosity} -ge 1 ]] && echo "skipping WD user"
                wsprdaemon_total=$((wsprdaemon_total + 1))
            else
                if [[ -n "${user_line:1}" ]]; then
                    eval declare $(echo "${user_line:1}" | sed '/"\([^"]*\)":/s//\1=/g')
                    local listener_channel="${user_line:0:1}"
                    local listener_name="$(echo "$n" | sed 's/%20/ /g')"
                    local listener_location="$(echo "$g" | sed 's/%20//g')"
                    local listener_freq="$f"
                    local listener_mode="$m"
                    local listener_ip="$a"
                    local listener_time="$t"
                    printf "%12s:%s %15s %8s %3s %s %20s %s\n" "${kiwi_name}" "${listener_channel}" "'${listener_name}'" "${listener_freq}" "${listener_mode}" "${listener_time}" "${listener_ip}" "${listener_location}"
                    users_total=$((users_total + 1))
                fi
            fi
        done < /tmp/curl.log
    done
    printf "Found %d Kiwis configured for %d total rx channels, %d total listeners, %d wsprdaemon channels\n" "${#kiwi_list[@]}" $channels_total  $users_total $wsprdaemon_total
}

### Aliases which call WD
alias wd='~/wsprdaemon/wsprdaemon.sh'
alias wdl='wd -l'
alias wdle='wd -l e'
alias wdld='wd -l d'
alias wda='wd -a'
alias wdz='wd -z'
alias wds='wd -s'
alias wdv='wd -V'
alias wdd='wd -d'       ### Increment the verbosity level of all running daemons in CWD
alias wddd='wd -D'      ### Decrement

function wd-merged() {
    local merged_file_list=( $(find ${WD_TMP_ROOT}/ -name merged.log  | sort -t / -k 7nr ) )
    local merged_file_count=${#merged_file_list[@]}
    if [[ ${#merged_file_list[@]} -eq 0 ]]; then
        echo "There are no 'merged.log' files"
        return 0
    fi
    echo "Found ${#merged_file_list[@]} 'merged.log' files:"
    local i
    for  (( i = 0; i < ${merged_file_count}; ++i )); do
        #set -x
        local file_line_list=( $(ls -l ${merged_file_list[${i}]}) )
        local merge_log_line_count=$( wc -l < ${merged_file_list[${i}]} )
        printf "%2d:  %-70s %s %2s %s %6s bytes = %4d lines\n" ${i} ${file_line_list[-1]} ${file_line_list[-4]}  ${file_line_list[-3]}  ${file_line_list[-2]}  ${file_line_list[-5]} ${merge_log_line_count}
    done
    if [[ "${1}" == "-k" ]]; then
         wd-merged-kfs -n
    fi
    return 0
}

function wd-merged-kfs() {
    local merged_file_list=( $(find ${WD_TMP_ROOT}/ -name merged.log | sort -t / -k 7nr) )      ### sort by ascending band freqeuncy
    local merged_file_count=${#merged_file_list[@]}
    if [[ ${merged_file_count} -eq 0 ]]; then
        echo "There are no 'merged.log' files"
        return 0
     fi
     [[ "${1}" != "-n" ]] && echo "Found ${merged_file_count} 'merged.log' files:"
     local default_index=0
     local i
     for  (( i = 0; i < ${merged_file_count}; ++i )); do
         local file_path_list=( ${merged_file_list[${i}]//\// } )
         if [[ "${file_path_list[-2]}" == "20" ]]; then
             default_index=${i}
         fi
         [[ "${1}" != "-n" ]] && printf "%2s: %s\n" ${i}   ${merged_file_list[${i}]}
     done

     local merge_log_file
     read -p "Select merged file to examine [0-${merged_file_count}], default = ${default_index} ? => "
     if [[ -z "${REPLY}" ]]; then
         REPLY=${default_index}
     fi
     local merged_log_file=${merged_file_list[${REPLY}]}
     echo "Examining  merged_log_file  ${merged_log_file} "
     awk '{printf "%s %s %s %s %s %s %10s %8s %10s   %9s %11s     %10s %10s     %10s %10s     %10s %10s       %10s\n", $1, $2, $3, $4, $5, $6, $7, $8, $9, $17, $13, $16, $12, $15, $11, $14, $10, $18}' ${merged_log_file} | less
}


declare WD_WAV_ARCHIVE_ROOT_DIR=~/wsprdaemon/wav-archive.d    ### No "" so ~ is expanded
### 11/2/22 - This doesn't work anymore, but it could be modifed 
function wd-grape-info(){
    local grape_date_dirs_list=( $( find ${WD_WAV_ARCHIVE_ROOT_DIR} -mindepth 1 -maxdepth 1 -type d | sort) )
    wd_logger 1 "Found ${#grape_date_dirs_list[@]} date dirs: ${grape_date_dirs_list[*]##*/}"
    local date_dir
    for date_dir in ${grape_date_dirs_list[@]}; do
        local file_count=$( find ${date_dir} -type f | wc -l )
        printf "Date %s contains %5d files: " ${date_dir##*/} ${file_count}
        case ${file_count} in
            0)
                read -N 1 -p "There are no files in the date ${date_dir##*/} tree, so delete that tree? [Yn] => "
                if [[ ${REPLY:-y} == "y" ]]; then
                    echo "\nDeleting directory tree ${date_dir}"
                    rm -r ${date_dir}
                fi
                ;;
            21)
                echo "has been purged of all but the sox.log, 24h.wav and the 'has been uploaded' files"
                ;;
            14421)
                echo "and is fill with 14400 flac files, the sox, wav and 'has been uploaded' files"
                ;;
            *)
                local date=$(printf "%(%Y%m%d)T")
                if [[ "${date_dir##*/}" == "${date}" ]]; then
                    echo "Skipping more checks for files being created today"
                else
                    read -p "has invalid number ${file_count} of files. List the non-flac files? => "
                    if [[ ${REPLY:-n} == "y" ]]; then
                        find ${date_dir} -type f ! -name '*.flac' | less
                    fi
                fi
                ;;
        esac
    done
}
alias wdgi='wd-grape-info'

function wd-wav-clean() {
    local wav_archive_root_dir_list=( $(find ${WD_WAV_ARCHIVE_ROOT_DIR} -mindepth 1 -maxdepth 1 -type d | sort) )
    local wav_archive_root_dir
    for wav_archive_root_dir in ${wav_archive_root_dir_list[@]} ; do
        local flat_file_list=( $(find ${wav_archive_root_dir} -type f | sort) )  
        if [[ ${#flat_file_list[@]} -eq 0 ]]; then
            read -p "wav file root dir ${wav_archive_root_dir} contains only directory files, so delete it? [Yn] => "
            if [[ "${REPLY:-y}" == "y" ]]; then
                rm -r ${wav_archive_root_dir}
            fi
        else
            printf "Found %6d files under %s\n"  ${#flat_file_list[@]}  ${wav_archive_root_dir}
        fi
    done
}

### At sites which are archiving wav files, this gets some info
alias wd-wav-archive='df -h ~ ; du -sh ~/wsprdaemon/wav-archive.d/ ; ls -lt ~/wsprdaemon/wav-archive.d/ | head  -n 3; ls -lt ~/wsprdaemon/wav-archive.d/ | tail -n 2'

function wd-wav-archive-fix(){
    source ~/wsprdaemon/wsprdaemon.conf
    if [[ -z "${GRAPE_PSWS_ID-}" ]]; then
        echo "This server is not configured with a GRAPE_PSWS_ID in the wsprdaemon.conf file, so can't fix the directories"
        return 0
    fi
    if ! [[ ${GRAPE_PSWS_ID} =~ _ ]]; then
        echo "GRAPE_PSWS_ID='${GRAPE_PSWS_ID}' does not match the expected format 'Snnnn_nnn'"
        return 0
    fi
    local date_dir
    for date_dir in $(find ${WD_WAV_ARCHIVE_ROOT_DIR} -mindepth 1 -maxdepth 1 -type d | sort ); do 
        #echo "date_dir = ${date_dir}"
        local reporter_dir
        for reporter_dir in $(find ${date_dir} -mindepth 1 -maxdepth 1 -type d | sort ); do
            #echo "reporter_dir = ${reporter_dir}"
            local receiver_dir
            for receiver_dir in $(find ${reporter_dir} -mindepth 1 -maxdepth 1 -type d | sort ); do
                echo  "Examining  ${receiver_dir} "
                if [[ ${receiver_dir} =~ "@" ]] &&  ! [[  ${receiver_dir##*@} =~ "_" ]]; then
                    read -p "Fix ${receiver_dir} to become ${receiver_dir}_${GRAPE_PSWS_ID#*_}? "
                    mv  ${receiver_dir} ${receiver_dir}_${GRAPE_PSWS_ID#*_}
                elif ! [[ ${receiver_dir} =~ "@" ]]; then
                   read -p  "Fix receiver directory ${receiver_dir} by renaming it to ${receiver_dir}@${GRAPE_PSWS_ID}? => "
                   mv ${receiver_dir} ${receiver_dir}@${GRAPE_PSWS_ID}
                fi
            done
        done
    done
}
alias wdwaf=wd-wav-archive-fix

function wd-ssh-psws(){
    source ~/wsprdaemon/wsprdaemon.conf
    if [[ -z "${GRAPE_PSWS_ID-}" ]]; then
        echo "This server is not configured with a GRAPE_PSWS_ID in the wsprdaemon.conf file, so can't fix the directories"
        return 0
    fi
    if ! [[ ${GRAPE_PSWS_ID} =~ _ ]]; then
        echo "GRAPE_PSWS_ID='${GRAPE_PSWS_ID}' does not match the expected format 'Snnnn_nnn'"
        return 0
    fi
    wd_logger 1 "Executing: 'ssh ${GRAPE_PSWS_ID%_*}@pswsnetwork.caps.ua.edu'"
    ssh ${GRAPE_PSWS_ID%_*}@pswsnetwork.caps.ua.edu
}
alias wdssp=wd-ssh-psws

function wd-overloads()
{
: <<"comment_out"
    local log_file_list=( $(find /dev/shm/wsprdaemon/ -name wav_status.log | sort ) )
    #printf "Searching ${#log_file_list[@]} 'wav_status.log' files for WAV overload events\n%-40s YYMMDD_HHMM      MIN_SAMPLE MAX_SAMPLE Count_of MIN/MAX\n" "RECIEVER/BAND/log_file"

    if [[ ${#log_file_list[@]} -eq 0 ]]; then
        echo "Can't find any 'wav_status.log' files, so this must be an older version of WD"
    else
       true  #awk '$2 == -1.0 || $3 == 1.0 { printf( "%-40s %s\n", substr(FILENAME,33) ":", $0) } ' ${log_file_list[@]}
    fi
comment_out

    log_file_list=( $(find /dev/shm/wsprdaemon/ -name kiwi_ovs.log | sort ) )
    if [[ ${#log_file_list[@]} -eq 0 ]]; then
        echo "Can't find any 'kiwi_ovs.log' files"
        return
    fi

    if [[ $# -ne 0 && "$1" == "-f" ]]; then
        read -p "Press <ENTER> to flush all of the ${#log_file_list[@]} kiwi_ovs.log files => "
        rm ${log_file_list[@]}
        return
    fi

    ### Get a list of the Kiwis
    local kiwi_list=()
    local kiwi_root_path_list=()
    local file_path
    for file_path in ${log_file_list[@]} ; do
        local file_path_list=( ${file_path//\// } )         ### put each directory name in an element of an array
        local kiwi_name=${file_path_list[-3]-}              ### two directories up from the log file is the directory with the name of the kiwi
        set +x
        if [[ ! " ${kiwi_list[*]} " =~ " ${kiwi_name} " ]]; then
            kiwi_list+=("${kiwi_name}")
           local temp_path_list
           temp_path_list=(${file_path//\// })
           local kiwi_root_path=${temp_path_list[@]:0:$(( ${#temp_path_list[@]} - 2 ))}    ### chop off BAND/kiwi_ovs.log
           kiwi_root_path="/${kiwi_root_path// /\/}"
           #echo "kiwi_root_path = ${kiwi_root_path}"
           kiwi_root_path_list+=(${kiwi_root_path})
           set +x
           #read -p "Next Kiwi path => "
        fi
        set +x
    done
    printf "Found there are ${#kiwi_list[@]} Wsprdaemon Kiwis: ${kiwi_list[*]}\n\n"
    #echo "Found there are ${#kiwi_root_path_list[@]} Kiwi root paths: ${kiwi_root_path_list[*]}"

    for kiwi_root_path in ${kiwi_root_path_list[@]} ; do
        #echo "Searching under ${kiwi_root_path}"
        local kiwi_name=${kiwi_root_path##*/}
        log_file_list=( $(find ${kiwi_root_path}  -name kiwi_ovs.log | sort ) )

        local newest_log_file=$(ls -1t ${log_file_list[@]} | head -1)
        local most_ovs_line=$(sort -k 3n ${newest_log_file} | awk '$2 != $3' | tail -n 1)
        local ov_report_count=$( wc -l < ${newest_log_file})
        local ov_non_zero_count=$(awk '$3 != 0' ${newest_log_file} | wc -l)

        local most_ovs_line_list=( ${most_ovs_line} )
        if [[ ${most_ovs_line_list[2]-0} -eq 0 ]]; then
            printf "Kiwi ${kiwi_name} reports no overload events\n\n"
            continue
        fi

        printf "For Kiwi '${kiwi_name}' found in '${newest_log_file}', the newest of the ${#log_file_list[@]} 'kiwi_ovs.log' files:\n"
        printf "There are %6d total wspr cycles in the log file, of which %6d cycles report overload events\n"  ${ov_report_count}  ${ov_non_zero_count}
        printf "This line which reports the most OVs:\n${most_ovs_line}\n" 

        read -p "Press 'l + <RETURN>' to execute 'less ${newest_log_file}', then search for ${most_ovs_line_list[0]} => " user_input
        if [[ -n "${user_input}" ]]; then
            less ${newest_log_file}
        fi
        printf "\n"
    done
}
alias wd-ov='wd-overloads'
alias wdov='wd-ov'

function wd-query()
{
    if [[ $# -lt 1 ]]; then
        echo "usage:  wd-query {-r | -t} ID [HOURS_TO_SEARCH]       -r => search for ID of reporter     -t => search for ID of transmit beacon"
        return 0
    fi
    local query_target_field="rx_id"
    case $1 in
        -r) query_target_field="rx_id";shift ;;
        -t) query_target_field="tx_call";shift ;;
    esac
    if [[ $# -lt 1 ]]; then
        echo "ERROR: missing ID"
        echo "usage:  wd-query {-r | -t} ID [HOURS_TO_SEARCH]       -r => search for ID of reporter     -t => search for ID of transmit beacon"
        return 1
    fi
    local target_val=$1
    local query_hours=${2-1}
    local query_minutes=$((query_hours * 60))

    PGPASSWORD=JTWSPR2008 psql -U wdread -h wsprdaemon.org -p 5432 -d tutorial -c \
        "select time,tx_call,tx_grid,rx_id,receiver,rx_grid,freq,\"tx_dBm\",\"SNR\",drift,mode,metric as \"S width (mHz)\" from wsprdaemon_spots_s where ${query_target_field}='${target_val}' and mode >0 and time > now() - interval '${query_minutes} minutes' order by (time,rx_id,receiver) desc;"
}
alias wd-q='wd-query'
alias wdq='wd-query'

alias wd-syslog='sudo tail -F /var/log/syslog'
alias wd-syslogl='sudo less /var/log/syslog'
alias wdsl='wd-syslog'
alias wd-wd-rec='watch "ps aux | grep wd-rec | grep -v grep | sort -k 14,14n -k 15r"'
alias wdwd='wd-wd-rec'
function wd-wd-rec-flush()
{
    local wd_record_pids=( $(ps aux | grep wd-rec | grep -v grep | awk '{print $2}') )
    if [[ ${#wd_record_pids[@]} -gt 0 ]]; then
        echo "Flushing ${#wd_record_pids[@]} wd-record jobs"
        kill ${wd_record_pids[@]}
    fi
}

function wd-freqs(){
    local rec_root_dir="/dev/shm/wsprdaemon/recording.d"
    local rec_rx_root_dir_list=( $( find ${rec_root_dir}/* -type d -prune ) )
    local rec_bands_list=( $( find ${rec_root_dir} -mindepth 2 -maxdepth 2 -type d ! -name kiwi_status.d -printf "%f\n" | sort -u ) )

    local first_print="yes"
    for band in ${rec_bands_list[@]}; do
        if [[ ${first_print} == "no" ]]; then
            echo
        fi
        first_print=no
        for rx_root_dir in ${rec_rx_root_dir_list[@]} ; do
            local rx_name=${rx_root_dir##*/}
            echo -n "${rx_name}: "
            local rx_band_dir=${rx_root_dir}/${band}
            if [[ -d ${rx_band_dir} ]]; then
                printf "%s" "$( grep "^23.*AI6" ${rx_band_dir}/decoding_daemon.log | tail -n 1)"
            fi
            echo
        done | sort
    done
}

function wd-wavs() {
    local rx_band=$1

    if [[ -z "${rx_band}" ]]; then
        echo "usage: wd-wavs BAND"
        return 0
    fi

    for rx_dir in */${band} ; do
        ls -lt ${rx_dir}/${rx_band}/*.wav | head -1
    done
    return 0

    local rec_root_dir="/dev/shm/wsprdaemon/recording.d"
    local rec_rx_root_dir_list=( $( find ${rec_root_dir}/* -type d -prune ) )
    local rec_bands_list=( $( find ${rec_root_dir} -mindepth 2 -maxdepth 2 -type d ! -name kiwi_status.d -printf "%f\n" | sort -u ) )

    local first_print="yes"
    for band in ${rec_bands_list[@]}; do
        echo =n ${band}
    done
}

### Monitor and control the KA9Q-radio service
###
function wd-get_ka9q-conf_file-base_name() {
    source ~/wsprdaemon/wsprdaemon.conf
    local conf_base_name=${KA9Q_CONF_NAME:-rx888-wsprdaemon}
    echo "${conf_base_name}"
}

function wd-get-ka9q-conf-file-path () {
    local base_name=$(wd-get_ka9q-conf_file-base_name)
    local conf_file_path="/etc/radio/radiod@${base_name}.conf"
    if [[ ! -f ${conf_file_path} ]]; then
        echo "ERROR: can't find expected conf file: ${conf_file_path}"
        return 1
    fi
    echo ${conf_file_path}
    return 0
}

#alias wd-rl='sudo journalctl -u radiod@rx888-wsprdaemon.service'     ### show the syslog entries for the radiod service.  add -f to watch new log lines appear
function wd-rl() {
    local rl_args=${@--n 40}
    local base_name=$(wd-get_ka9q-conf_file-base_name)
    sudo journalctl -u radiod@${base_name} -f ${rl_args}
}
alias wdrl='wd-rl'

function wd-radiod-action(){
   local action=$1
   local base_name=$(wd-get_ka9q-conf_file-base_name)
   sudo systemctl ${action} radiod@${base_name}.service
}

alias wd-ra='wd-radiod-action start'  ### show it's status
alias wdra='wd-ra'

alias wd-rz='wd-radiod-action stop'  ### show it's status
alias wdrz='wd-rz'

alias wd-rs='wd-radiod-action status'  ### show it's status
alias wdrs='wd-rs'

function wd-radiod-conf-edit() {
   local conf_file_path

   if ! conf_file_path=$(wd-get-ka9q-conf-file-path); then
       echo "ERROR: ${conf_file_path}"
       return 1;
   fi
   vi ${conf_file_path}
}
alias wdrv='wd-radiod-conf-edit'

### WD systemctl 
alias wd-wd-start='sudo systemctl start wsprdaemon.service'
alias wdwa='wd-wd-start'

alias wd-wd-stop='sudo systemctl stop wsprdaemon.service'
alias wdwz='wd-wd-stop'

alias wd-wd-status='sudo systemctl status wsprdaemon.service'
alias wdws='wd-wd-status'

### Checks that the radiod config file is set with the desired low = 1300, high = 1700 and fix them if they were set to 100, 5000 by WD 3.1.4
function wd-radiod-bw-check() {
    local running_radiod_conf_file=$( sudo systemctl status | grep -v awk | awk '/\/etc\/radio\/radiod.*conf/{print $NF}' )
    if [[ -z "${running_radiod_conf_file}" ]]; then
        wd_logger 1 "radiod is not configured to run on this server"
        return 0
    fi
    local rx_audio_low=$( awk '/^low =/{print $3;exit}' ${running_radiod_conf_file})     ### Assume that the first occurence of '^low' and '^high' is in the [WSPR] section
    local rx_audio_high=$( awk '/^high =/{print $3;exit}' ${running_radiod_conf_file})
    wd_logger 2 "In ${running_radiod_conf_file}: low = ${rx_audio_low}, high = ${rx_audio_high}"

    if [[ -z "${rx_audio_low}" || -z "${rx_audio_high}" ]]; then
        wd_logger 1 "ERROR: can't find the expected low and/or high settings in  ${running_radiod_conf_file}"
        return 1
    fi
    local rx_needs_restart="no"
    if [[ "${rx_audio_low}" != "1300" ]]; then
        wd_logger 1 "WARNING: found low = ${rx_audio_low}, so changing it to the desired value of 1300"
        sed -i "0, /^low =/{s/low = ${rx_audio_low}/low = 1300/}"  ${running_radiod_conf_file}      ### Only change the first 'low = ' line in the conf file
        rx_needs_restart="yes"
    fi
    if [[ "${rx_audio_high}" != "1700" ]]; then
        wd_logger 1 "WARNING: found high = ${rx_audio_high}, so changing it to the desired value of 1700"
        sed -i "0, /^high/{s/high = ${rx_audio_high}/high = 1700/}"  ${running_radiod_conf_file}
        rx_needs_restart="yes"
    fi
    if [[ ${rx_needs_restart} == "no" ]]; then
        wd_logger 2 "No changes needed"
    else
        wd_logger 1 "Restarting the radiod service"
        local radiod_service_name=${running_radiod_conf_file##*/}
        radiod_service_name=${radiod_service_name/.conf/.service}
        sudo systemctl restart ${radiod_service_name}
    fi
    return 0
}

function wd-9qstats() {
    local root_dir="/dev/shm/wsprdaemon/posting.d/MERG_6_Q"
    local band_dir_list=( $(find ${root_dir} -maxdepth 1 -type d -not -wholename ${root_dir}) )
    local band_list=( ${band_dir_list[@]##*/} )

    echo "Band  Total  Q Missed       SNR    Kiwi Missed       SNR  SNR Diff"
    for band_dir in ${band_list[@]}  ; do
        local merged_log_file
        merged_log_file=${root_dir}/${band_dir}/merged.log
        if [[ ! -f ${merged_log_file} ]]; then
            echo "${band_dir}: No    merged.log in ${root_dir}/${band_dir}"
        else
            local spots_info_list=( $(awk '! /FREQUENCY/{++spots_count};\
                                     $10 == "*" {++q_missed_count};\
                                     $11 == "*" {++kiwi_missed_count};\
                                     ! /FREQUENCY/ && $10 != "*" && $11 != "*" { q_spots_sum += $10; kiwi_spots_sum += $11; ++sum_count} ;\
                                     END {printf "%5d %5d %4.2f%% %f %5d  %4.2f%% %f   %f\n", \
                                                 spots_count,\
                                                 q_missed_count,  (q_missed_count/spots_count)*100, q_spots_sum /sum_count,\
                                                 kiwi_missed_count, (kiwi_missed_count/spots_count)*100, kiwi_spots_sum/sum_count,\ 
                                                (kiwi_spots_sum/sum_count) - (q_spots_sum /sum_count) }'  ${merged_log_file}) )
            #echo "spots_info_list[] = '${spots_info_list[*]}'"
            local spots_count=${spots_info_list[0]}
            local q_missed_count=${spots_info_list[1]}
            local q_missed_percent=${spots_info_list[2]}
            local q_average=${spots_info_list[3]}
            local kiwi_missed_count=${spots_info_list[4]}
            local kiwi_missed_percent=${spots_info_list[5]}
            local kiwi_average=${spots_info_list[6]}
            local spots_diff_average=${spots_info_list[7]}

            printf "%4d: %5d   %4d %6s %5.1f        %4d %6s %5.1f   %4.2f\n" \
                ${band_dir} ${spots_count} ${q_missed_count} ${q_missed_percent} ${q_average} ${kiwi_missed_count} ${kiwi_missed_percent} ${kiwi_average} ${spots_diff_average}
        fi
    done
}

declare -A KA9Q_band_freq=(
    [160]="1836600"
    [80]="3568600"
    [60]="5287200"
    [40]="7038600"
    [30]="10138700"
    [20]="14095600"
    [17]="18104600"
    [15]="21094600"
    [12]="24924600"
    [10]="28124600"
     [6]="50293000"
)

function wd-radiod-control()
{
    local band=${1-20}
    local tuning_freq=${KA9Q_band_freq[${band}]}
    local mc_url

    local radiod_conf_base_name=$(wd-get_ka9q-conf_file-base_name)
    if [[ "${radiod_conf_base_name}" == "rx888-wsprdaemon" ]]; then
        mc_url="hf.local"
    else
        if [[ -z "${2-}" ]]; then
            mc_url="hf-${radiod_conf_base_name}-status.local"
        else
            mc_url="hf-${2}-status.local"
        fi
    fi

    control -s ${tuning_freq} ${mc_url}
}
alias wd9c=wd-radiod-control
alias wdrc=wd-radiod-control

function wd-9m()
{
    local header_printed="no"
    local band
    for band in $( IFS=$'\n'; echo "${!KA9Q_band_freq[*]}" | sort -n ); do
        local metadump_out=$(metadump -n -c 1 -s ${KA9Q_band_freq[${band}]} hf.local)
        local rf_gain=$(echo "${metadump_out}" | awk '/rf gain/{print $(NF - 1) }')
        local if_power=$(echo "${metadump_out}" | awk '/IF pwr/{print $(NF - 1) }')
        local noise_level=$(echo "${metadump_out}" | awk '/N0 /{print $(NF - 1) }')
        local agc_enable=$(echo "${metadump_out}" | awk '/agc /{print $(NF - 0) }')
        local baseband_pwr=$(echo "${metadump_out}" | awk '/baseband pwr/{print $(NF - 1) }')
        local output_level=$(echo "${metadump_out}" | awk '/output level/{print $(NF - 1) }')
        local headroom=$(echo "${metadump_out}" | awk '/headroom/{print $(NF - 1) }')
        local agc_gain=$(echo "${metadump_out}" | awk '/) gain/{print $(NF - 1) }')

        if [[ ${header_printed} == "no" ]]; then
            printf "RF Gain = %4.1f, AGC %s, AGC gain %4.1f\n" ${rf_gain} ${agc_enable} ${agc_gain}
            printf "Band  IF_power  Noise_level  Baseband_power Output_level  Headroom\n" 
            header_printed="yes"
        fi
        ##     band    if_power noise_level    baseband_pwr   output_level  headroom
        printf "%3d      %6.1f      %6.1f          %6.1f       %6.1f    %6.1f\n" ${band} "${if_power}" "${noise_level}" "${baseband_pwr}" "${output_level}" "${headroom}"
    done
}
alias wd9m=wd-9m

### tmux alias
function tm() {
    # set -x
    local tm_arg=${1-}
    local tm_list=( $(tmux ls 2> /dev/null | awk -F : '{print $1}') )
    local tm_list_count=${#tm_list[@]}

    if [[ -z "${tm_arg}" ]]; then
        #set +x && return
        if [[ ${tm_list_count} -eq 0 ]]; then
            tmux
            return 0
        fi
        if [[ ${tm_list_count} -eq 1 ]]; then
            tmux a -t ${tm_list[0]}
            return 0
        fi
    fi

    printf "There are ${tm_list_count} active tmux sessions:\n"
    readarray -t tm_list <  <(tmux ls)
    local i
    for (( i = 0; i < ${#tm_list[@]}; ++i )); do
        local tm_session="${tm_list[${i}]}"
        printf "#%s\n" "${tm_session}"
    done
    if [[ "${tm_arg}" == "-l" ]]; then
        return 0
    fi
    local tm_default_id=$(echo "${tm_list[0]}"  | awk -F : '{print $1}')
    read -p "Select tmux session id # (default = ${tm_default_id})? => "
    if [[ -z "${REPLY}" ]]; then
        REPLY="${tm_default_id}"
    fi
    for (( i = 0; i < ${#tm_list[@]}; ++i )); do
        local tm_session="${tm_list[${i}]}"
        local tm_session_id=$( echo "${tm_session}" | awk -F : '{print $1}' )
        if [[ "${tm_session_id}" == "${REPLY}" ]]; then
            tmux a -t ${tm_session_id} 
            return 0
        fi
    done
    echo "${REPLY} is not a valid id"
    return 0
}

function wd-wait-for_wspr-gap(){
   printf "Starting at %(%M-%S)T and waiting for the next gap in the WSPR-2 packets\n" -1
   while printf -v minute "%(%M)T\n" -1 && printf -v sec "%(%S)T\n" -1 && [[ $(( minute % 2 )) -ne 1 || 10#${sec} -lt 55 ]]; do 
       [[ ${verbosity-0} -gt 0 ]] &&printf '%(%M-%S)T\n' -1
       sleep 1; 
   done
}
alias wd-wait='wd-wait-for_wspr-gap'

alias wd-nf="awk '{printf \"%2d: %s\n\", NF, \$0}'"

### git aliases

### Change a ~/wsprdaemon from https:..(git read only) to git@github.com (git read/write) so you can check in WD source code changes
function  wd-git-to-ssh(){
    local current_url=$(git remote get-url origin)
    if ! [[ "${current_url}" =~ https ]]; then
        echo "Nothing to do since current_url='${current_url}' doesn't contain the string 'https'"
        return 0
    fi
    local repo_name=${current_url/*github.com\//}
    local new_repo_url="git@github.com:${repo_name}"
    read -p "Change git's url from '${current_url}' to '${new_repo_url}'? => "
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob Robinett"
    git remote set-url origin ${new_repo_url}
    if ! [[ -d ~/.ssh ]]; then
        echo "There is no local ssh public key file.  Runnning 'ssh-keygen to generate one.  Press <CR> to accept all of its defaults:"
        ssh-keygen
    fi
    local public_key_file=$(find ~/.ssh -type f -name '*pub')
    if [[ -z "${public_key_file}" ]]; then
        echo "There is no local ssh public key file.  Runnning 'ssh-keygen to generate one.  Press <CR> to accept all of its defaults:"
        ssh-keygen
    fi
    public_key_file=$(find ~/.ssh -type f -name '*pub')
    if [[ -z "${public_key_file}" ]]; then
        echo "There is still no local ssh public key file, this has failed"
        return 1
    fi
    echo "Copy and paste this ssh public key to the github.com account:"
    echo "$(< ${public_key_file})"
    return 0
}

alias wd-get-my-public_ip="dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | sed 's/\"//g'"

alias wd-watch-wavs='watch "ls -lr *.wav"'  ### watch for wd-record or kiwirecorder to create wav files in cwd
alias wdww='wd-watch-wavs'
alias wdps='ps aux | grep wd-record | grep -v grep'

function wd-ssh-to-wdclient() {
    local rac_id=${1:-usage}

    if [[ "${rac_id}" == "usage" ]]; then
        echo "usage:   wd-ssh-to-wdclient (or wdssr) RAD_ID"
        return 0
    fi
    if [[ ${#rac_id} -eq 1 ]]; then
        rac_id="0${rac}"
    fi
    ssh -p 358${rac_id} wsprdaemon@wsprdaemon.org
}
alias wdssr=wd-ssh-to-wdclient

###  Reloads these functions and aliases into the users running bash (must be an alias)
alias wd-bash_aliases='source ~/wsprdaemon/bash-aliases'
alias wdba='wd-bash_aliases'

function wd-help()
{
    echo "Programs which print information about Wsprdaemon (WD) system:
Command       Can also be executed by    Description
wd-help       wd-h wd-                   Prints this help message
wd-start      wd-a wda                   Start or keep running WD
wd-stop       wd-z wdz                   Stop WD if it is running
wd-status     wd-s wds                   Show the status of a running WD 
wd-upload-wn  wd-un wdln                 Watch the 'upload to wsprnet' log
wd-upload-wd  wd-uw wdlw                 Watch the 'upload to wsprdaemon' log
wd-errors     wd-e wdle                  Each 10 seconds, search all the log files and print newly logged 'ERROR' lines
wd-overloads  wd-ov wdov                 Prints all overload events recorded in the wav and ADC log files 
wd-query      wd-q wdq                   Query the wsprdaemon database for spots
wd-gc                                    Execute git commit
wd-gp                                    Execute git push
wq-gl                                    Execute git log
wd-gc-ssh                                Execute git remote set-ur + git config
"
}
alias wd-='wd-help'
alias wd-h='wd-help'

if [[ ! -f ~/.tmux.conf ]]; then
    echo "set -g mouse on" > ~/.tmux.conf
fi

alias wdg='wd -g'

###  Runs du and sorts output by name rather than ???   Useful in the ~/wsprdaemon/wav-archive directory
function wddu() {
    local files="$@"

    du -s ${files}  | awk '{print $2 ":  " $1}'
}

### Copy a 2 minute wav file to /tmp
function wd-wav-capture() {
    local wav_file
    echo -n "$(date): Waiting for the 2 minute long wav file to appear after the next even 2 minutes: "
    while ! wav_file=$(ls 2?????_*.wav 2> /dev/null ); do 
         echo -n "."
         sleep .25
     done
     cp ${wav_file} /tmp/
     echo 
     echo "$(date): Captured /tmp/${wav_file}"
}

